<h1 id="warp">Warp</h1>
<p>Authors: Michael Snoyman and Kazu Yamamoto</p>
<p>Warp is a high-performance HTTP engine library in Haskell, a purely functional programming language. Both Yesod, a web application framework, and Mighttpd, an HTTP server, are implemented over Warp. According to our throughput benchmark, Mighttpd provides performance on par with nginx. This article will explain the architecture of Warp and how we improved its performance.</p>
<h2 id="network-programming-in-haskell">Network programming in Haskell</h2>
<p>Some people believe that functional programming languages are slow or impractical. However, to the best of our knowledge, Haskell provides a nearly ideal approach for network programming. This is because the Glasgow Haskell Compiler (GHC), the flagship compiler of Haskell, provides light-weight and robust user threads (or sometime called green threads). In this section, we will briefly explain the history of server side network programming.</p>
<h3 id="native-threads">Native threads</h3>
<p>Traditional servers use a technique called thread programming. In this architecture, each connection is handled by a single process or native thread.</p>
<p>This architecture can be further segmented based on the mechanism for creating the processes or native threads. When using a thread pool, multiple processes or native threads are created in advance. An example of this is the prefork mode in Apache. Otherwise, a process or native thread is spawned each time a connection is received. Fig XXX illustrates this.</p>
<div class="figure">
<img src="1.png" alt="Native threads" /><p class="caption">Native threads</p>
</div>
<p>The advantage of this architecture is that it enables writing clear code, since the code is not divided into event handlers. Also, because the kernel assigns processes or native threads to available cores, we can balance utilization of cores. Its disadvantage is a large number of context switches between kernel and processes or native threads occur, resulting in performance degredation.</p>
<h3 id="event-driven">Event driven</h3>
<p>Recently, it has been said that event-driven programming is required to implement high performance servers. In this architecture multiple connections are handled by a single process (Fix XXX). Lighttpd is an example of web server using this architecture.</p>
<div class="figure">
<img src="2.png" alt="Event driven" /><p class="caption">Event driven</p>
</div>
<p>Since there is no need to switch processes, less context switches occur, and performance is thereby improved. This is its chief advantage. However, it has two shortcomings. The first is the fact that, since there is only a single process, only one core can be utilized. The second is that it requires asynchronous programming, so code is fragmented into event handlers. Asynchronous programming also prevents the conventional use of exception handling (although there are no exceptions in C).</p>
<h3 id="process-per-core">1 process per core</h3>
<p>Many have hit upon the idea of creating N event-driven processes to utilize multi-core processors where N is the number of cores. Port 80 must be shared for web servers. Using the prefork technique (please don't confuse with Apache's prefork mode), port sharing can be achieved, after slight code modifications. We call this &quot;1 process per core&quot; (Fig XXX).</p>
<div class="figure">
<img src="3.png" alt="1 process per core" /><p class="caption">1 process per core</p>
</div>
<p>One web server that uses this architecture is nginx. Node.js used the event-driven architecture in the past but it also implemented 1 process per core recently.</p>
<p>The advantage of this architecture is that it utilizes all cores of a multi-core processer and improves performance. However, it does not resolve the issue of programs having poor clarity.</p>
<h3 id="user-threads">User threads</h3>
<p>GHC's user threads can be used to solve the code clarity issue. They are implemented over an event-driven IO manager. GHC's user threads are light weight: modern computers can run 100,000 user threads smoothly. They are robust: even asynchronous exceptions are catch (we explain this later in detail).</p>
<p>Some languages and libraries provided user-space threads in the past, but they are not commonly used now because they are not lightweight or are not robust. But in Haskell, most computation is non-destructive. This means that almost all functions are thread-safe. GHC uses data allocation as a safe point of context switch of user threads. Because of functional programming style, new data are often created and it is known that <a href="http://www.aosabook.org/en/ghc.html">such data allocation is regulaly enough for context switching</a>.</p>
<p>Use of lightweight threads makes it possible to write code with good clarity like traditional thread programming while keeping high performance (Fig XXX).</p>
<div class="figure">
<img src="4.png" alt="Light-weight threads" /><p class="caption">Light-weight threads</p>
</div>
<h2 id="warps-architecture">Warp's architecture</h2>
<p>Warp is an HTTP engine for the Web Application Interface (WAI). It runs WAI applications over HTTP. As we described before, both Yesod and Mighttpd are examples of WAI applications as illustrated in Fix XXX.</p>
<div class="figure">
<img src="wai.png" alt="WAI" /><p class="caption">WAI</p>
</div>
<p>The type of WAI applications is as follows:</p>
<pre><code>type Application = Request -&gt; ResourceT IO Response</code></pre>
<p>In Haskell, argument types of function are separated by right arrows and the most right one is the type of return value. So, we can interpret the definition as an application takes <code>Request</code> and returns <code>Response</code>.</p>
<p>Warp first receives an HTTP request from a client and parses it to <code>Request</code>. Then, Warp gives the <code>Request</code> to an application and takes a <code>Response</code> from it. Finally, Warp builds an HTTP response based on <code>Response</code> and sends it back to the client. This is illustrated in Fix XXX.</p>
<div class="figure">
<img src="warp.png" alt="Warp" /><p class="caption">Warp</p>
</div>
<h2 id="performance-of-warp">Performance of Warp</h2>
<p>Before we explain how to improve the performance of Warp, we would like to show the results of our benchmark. We measured throughput of Mighttpd 2.8.2 and nginx 1.2.4. Our benchmark environment is as follows:</p>
<ul>
<li>One &quot;12 cores&quot; machine (Intel Xeon E5645, two sockets, 6 cores per 1 CPU, two QPI between two CPUs)</li>
<li>Linux version 3.2.0 (Ubuntu 12.04 LTS), which is running directly on the machine (i.e. without a hypervisor)</li>
</ul>
<p>We tested several benchmark tools in the past and our favorite one is <code>weighttp</code>. It is based on the <code>epoll</code> system call family and can use multiple native threads. We used <code>weighttp</code> as follows:</p>
<pre><code>weighttp -n 100000 -c 1000 -t 3 -k http://127.0.0.1:8000/</code></pre>
<p>This means that 1,000 HTTP connections are established and each connection sends 100 requests. 3 native threads are spawned to carry out these jobs.</p>
<p>For all requests, the same <code>index.html</code> file is returned. We used <code>nginx</code>'s <code>index.html</code>, whose size is 151 bytes. As &quot;127.0.0.1&quot; suggests, we measured web servers locally. We should have measured from a remote machine but we don't have suitable environment at this moment. (NOTE: I'm planning to do benchmark using two machines soon.)</p>
<p>Since Linux has many control parameters, we need to configure the parameters carefully. You can find a good introduction about Linux parameter tuning in <a href="http://gwan.com/en_apachebench_httperf.html">ApacheBench &amp; HTTPerf</a>.</p>
<p>We carefully configured both Mighty and <code>nginx</code> as follows:</p>
<ul>
<li>using file descriptor cache</li>
<li>no logging</li>
<li>no rate limitation</li>
</ul>
<p>Since our machine has 12 cores and <code>weighttp</code> uses three native threads, we measured web servers from one worker to eight workers(to our experience, three native thread is enough to measure 8 workers). Here is the result:</p>
<div class="figure">
<img src="multi-workers.png" alt="Performance of Warp and nginx" /><p class="caption">Performance of Warp and nginx</p>
</div>
<p>X-axis is the number of workers and y-axis means throughput whose unit is requests per second.</p>
<h2 id="lesson-learned">Lesson learned</h2>
<ol style="list-style-type: decimal">
<li>Issuing as few system calls as possible</li>
<li>Specialization and avoiding re-calculation</li>
<li>Avoiding locks</li>
</ol>
<h2 id="http-request-parser">HTTP request parser</h2>
<ul>
<li>Parser generator vs handmade parser</li>
<li>From &quot;Warp: A Haskell Web Server&quot;?</li>
<li>Conduit</li>
</ul>
<h2 id="http-response-builder">HTTP response builder</h2>
<h3 id="response-header">response header</h3>
<ul>
<li>Blaze builder vs low level memory operations</li>
</ul>
<h3 id="response-body">response body</h3>
<ul>
<li>Three types</li>
<li>Blaze builder</li>
<li>Conduit</li>
<li>sendfile</li>
</ul>
<h3 id="sending-header-and-body-together">sending header and body together</h3>
<ul>
<li>http://www.yesodweb.com/blog/2012/09/header-body</li>
</ul>
<h2 id="clean-up-with-timers">Clean-up with timers</h2>
<h3 id="for-connections">For connections</h3>
<ul>
<li>Requirements</li>
<li>System.Timeout.timeout</li>
<li>MVar vs IORef</li>
<li>Its algorithm</li>
</ul>
<p>Need a fig</p>
<h3 id="for-file-descriptors">For file descriptors</h3>
<ul>
<li>Requirements -- no leakage -- lookup -- multimap -- fast pruning</li>
<li>Red black tree</li>
</ul>
<p>Need a fig</p>
<h2 id="logging">Logging</h2>
<ul>
<li>Handle</li>
<li>From the Mighty article in Monad.Reader</li>
</ul>
<p>Need a fig</p>
<ul>
<li>date</li>
<li>avoiding gettimeofday()</li>
<li>caching the formatted date</li>
</ul>
<h2 id="other-tips">Other tips</h2>
<ul>
<li>accept4</li>
<li>char8</li>
<li>pessimistic read</li>
</ul>
<h2 id="profiling-and-benchmarking">Profiling and benchmarking</h2>
<ul>
<li>GHC profiler</li>
<li>httperf/weighttp</li>
<li>strace</li>
<li>eventlog</li>
<li>prof</li>
<li>tcpdump</li>
</ul>
<h2 id="conclusion">Conclusion</h2>
